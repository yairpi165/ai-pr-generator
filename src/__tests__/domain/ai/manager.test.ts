import { createProviderManager } from '../../../domain/ai/manager.js'
import { AI_CONSTANTS } from '../../../domain/ai/constants.js'
import type {
  AIConfig,
  AIProvider,
  AIResponse,
} from '../../../domain/ai/types.js'

// Mock the provider modules
jest.mock('../../../domain/ai/providers/openai.js')
jest.mock('../../../domain/ai/providers/gemini.js')

import { createOpenAIProvider } from '../../../domain/ai/providers/openai.js'
import { createGeminiProvider } from '../../../domain/ai/providers/gemini.js'

const mockCreateOpenAIProvider = createOpenAIProvider as jest.MockedFunction<
  typeof createOpenAIProvider
>
const mockCreateGeminiProvider = createGeminiProvider as jest.MockedFunction<
  typeof createGeminiProvider
>

describe('AI Provider Manager', () => {
  const mockOpenAIProvider: AIProvider = {
    name: 'OpenAI',
    isAvailable: jest.fn(),
    generateContent: jest.fn(),
  }

  const mockGeminiProvider: AIProvider = {
    name: 'Gemini',
    isAvailable: jest.fn(),
    generateContent: jest.fn(),
  }

  beforeEach(() => {
    jest.clearAllMocks()
    mockCreateOpenAIProvider.mockReturnValue(mockOpenAIProvider)
    mockCreateGeminiProvider.mockReturnValue(mockGeminiProvider)
  })

  describe('createProviderManager', () => {
    it('should create manager with both providers when both are available', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(true)
      expect(manager.getAvailableProviders()).toHaveLength(2)
      expect(manager.getAvailableProviders()[0].name).toBe('OpenAI')
      expect(manager.getAvailableProviders()[1].name).toBe('Gemini')
    })

    it('should create manager with only OpenAI when Gemini is not available', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(true)
      expect(manager.getAvailableProviders()).toHaveLength(1)
      expect(manager.getAvailableProviders()[0].name).toBe('OpenAI')
    })

    it('should create manager with only Gemini when OpenAI is not available', () => {
      const config: AIConfig = {
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(true)
      expect(manager.getAvailableProviders()).toHaveLength(1)
      expect(manager.getAvailableProviders()[0].name).toBe('Gemini')
    })

    it('should create manager with no providers when none are available', () => {
      const config: AIConfig = {}

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(false)
      expect(manager.getAvailableProviders()).toHaveLength(0)
    })
  })

  describe('generateContent', () => {
    it('should generate content using first available provider', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Generate a PR description'
      const expectedResponse: AIResponse = { text: 'Generated content' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).not.toHaveBeenCalled()
    })

    it('should fallback to second provider when first fails', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Generate a PR description'
      const expectedResponse: AIResponse = { text: 'Generated by Gemini' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI API error')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        `${AI_CONSTANTS.INFO.TRYING_NEXT_PROVIDER} OpenAI`
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        `${AI_CONSTANTS.INFO.PROVIDER_FAILED} OpenAI: OpenAI API error`
      )

      consoleSpy.mockRestore()
    })

    it('should throw error when no providers are available', async () => {
      const config: AIConfig = {}

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      await expect(manager.generateContent('test prompt')).rejects.toThrow(
        AI_CONSTANTS.ERRORS.NO_AI_PROVIDERS
      )
    })

    it('should throw error when all providers fail', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI error')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('Gemini error')
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)

      await expect(manager.generateContent('test prompt')).rejects.toThrow(
        AI_CONSTANTS.ERRORS.ALL_PROVIDERS_FAILED
      )

      consoleSpy.mockRestore()
    })
  })

  describe('generateContentWithProvider', () => {
    it('should generate content with specific provider', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Generate content with Gemini'
      const expectedResponse: AIResponse = { text: 'Gemini response' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const manager = createProviderManager(config)
      const result = await manager.generateContentWithProvider(
        'Gemini',
        testPrompt
      )

      expect(result).toEqual(expectedResponse)
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockOpenAIProvider.generateContent).not.toHaveBeenCalled()
    })

    it('should throw error when specified provider is not found', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      await expect(
        manager.generateContentWithProvider('Gemini', 'test prompt')
      ).rejects.toThrow("Provider 'Gemini' not found or not available")
    })

    it('should throw error when specified provider is not available', async () => {
      const config: AIConfig = {}

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      await expect(
        manager.generateContentWithProvider('OpenAI', 'test prompt')
      ).rejects.toThrow("Provider 'OpenAI' not found or not available")
    })
  })

  describe('getAvailableProviders', () => {
    it('should return a copy of the providers array', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)
      const providers1 = manager.getAvailableProviders()
      const providers2 = manager.getAvailableProviders()

      expect(providers1).toEqual(providers2)
      expect(providers1).not.toBe(providers2) // Should be different array instances
    })
  })
})
