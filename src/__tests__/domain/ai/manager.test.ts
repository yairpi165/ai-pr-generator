import { createProviderManager } from '../../../domain/ai/manager.js'
import { AI_CONSTANTS } from '../../../domain/ai/constants.js'
import type {
  AIConfig,
  AIProvider,
  AIResponse,
} from '../../../domain/ai/types.js'

// Mock the provider modules
jest.mock('../../../domain/ai/providers/openai.js')
jest.mock('../../../domain/ai/providers/gemini.js')

import { createOpenAIProvider } from '../../../domain/ai/providers/openai.js'
import { createGeminiProvider } from '../../../domain/ai/providers/gemini.js'

const mockCreateOpenAIProvider = createOpenAIProvider as jest.MockedFunction<
  typeof createOpenAIProvider
>
const mockCreateGeminiProvider = createGeminiProvider as jest.MockedFunction<
  typeof createGeminiProvider
>

describe('AI Provider Manager', () => {
  const mockOpenAIProvider: AIProvider = {
    name: 'OpenAI',
    isAvailable: jest.fn(),
    generateContent: jest.fn(),
  }

  const mockGeminiProvider: AIProvider = {
    name: 'Gemini',
    isAvailable: jest.fn(),
    generateContent: jest.fn(),
  }

  beforeEach(() => {
    jest.clearAllMocks()
    mockCreateOpenAIProvider.mockReturnValue(mockOpenAIProvider)
    mockCreateGeminiProvider.mockReturnValue(mockGeminiProvider)
  })

  describe('createProviderManager', () => {
    it('should create manager with both providers when both are available', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(true)
      expect(manager.getAvailableProviders()).toHaveLength(2)
      expect(manager.getAvailableProviders()[0].name).toBe('OpenAI')
      expect(manager.getAvailableProviders()[1].name).toBe('Gemini')
    })

    it('should create manager with only OpenAI when Gemini is not available', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(true)
      expect(manager.getAvailableProviders()).toHaveLength(1)
      expect(manager.getAvailableProviders()[0].name).toBe('OpenAI')
    })

    it('should create manager with only Gemini when OpenAI is not available', () => {
      const config: AIConfig = {
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(true)
      expect(manager.getAvailableProviders()).toHaveLength(1)
      expect(manager.getAvailableProviders()[0].name).toBe('Gemini')
    })

    it('should create manager with no providers when none are available', () => {
      const config: AIConfig = {}

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      expect(manager.hasAvailableProviders()).toBe(false)
      expect(manager.getAvailableProviders()).toHaveLength(0)
    })
  })

  describe('generateContent', () => {
    it('should generate content using first available provider', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Generate a PR description'
      const expectedResponse: AIResponse = { text: 'Generated content' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).not.toHaveBeenCalled()
    })

    it('should fallback to second provider when first fails', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Generate a PR description'
      const expectedResponse: AIResponse = { text: 'Generated by Gemini' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI API error')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        AI_CONSTANTS.INFO.FALLBACK_TO_PROVIDER.replace('{provider}', 'OpenAI')
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider OpenAI failed: OpenAI API error')
      )

      consoleSpy.mockRestore()
    })

    it('should throw error when no providers are available', async () => {
      const config: AIConfig = {}

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      await expect(manager.generateContent('test prompt')).rejects.toThrow(
        AI_CONSTANTS.ERRORS.NO_AI_PROVIDERS
      )
    })

    it('should throw error when all providers fail', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI error')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('Gemini error')
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)

      await expect(manager.generateContent('test prompt')).rejects.toThrow(
        AI_CONSTANTS.ERRORS.ALL_PROVIDERS_FAILED
      )

      consoleSpy.mockRestore()
    })
  })

  describe('generateContentWithProvider', () => {
    it('should generate content with specific provider', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Generate content with Gemini'
      const expectedResponse: AIResponse = { text: 'Gemini response' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const manager = createProviderManager(config)
      const result = await manager.generateContentWithProvider(
        'Gemini',
        testPrompt
      )

      expect(result).toEqual(expectedResponse)
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockOpenAIProvider.generateContent).not.toHaveBeenCalled()
    })

    it('should throw error when specified provider is not found', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      await expect(
        manager.generateContentWithProvider('Gemini', 'test prompt')
      ).rejects.toThrow("Provider 'Gemini' not found or not available")
    })

    it('should throw error when specified provider is not available', async () => {
      const config: AIConfig = {}

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)

      await expect(
        manager.generateContentWithProvider('OpenAI', 'test prompt')
      ).rejects.toThrow("Provider 'OpenAI' not found or not available")
    })
  })

  describe('getAvailableProviders', () => {
    it('should return a copy of the providers array', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)
      const providers1 = manager.getAvailableProviders()
      const providers2 = manager.getAvailableProviders()

      expect(providers1).toEqual(providers2)
      expect(providers1).not.toBe(providers2) // Should be different array instances
    })
  })

  describe('getDefaultProvider', () => {
    it('should return default provider when configured', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
        defaultProvider: 'OpenAI',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBe('OpenAI')
    })

    it('should return null when no default provider is configured', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBeNull()
    })

    it('should return null when defaultProvider is empty string', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        defaultProvider: '',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBeNull()
    })

    it('should return null when defaultProvider is undefined', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        defaultProvider: undefined,
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBeNull()
    })

    it('should return case-sensitive default provider', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        defaultProvider: 'Gemini',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBe('Gemini')
    })

    it('should return default provider even when no providers are available', () => {
      const config: AIConfig = {
        defaultProvider: 'OpenAI',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(false)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(false)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBe('OpenAI')
    })

    it('should handle custom provider names', () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        defaultProvider: 'CustomProvider',
      }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)

      const manager = createProviderManager(config)
      const defaultProvider = manager.getDefaultProvider()

      expect(defaultProvider).toBe('CustomProvider')
    })
  })

  describe('generateContent with defaultProvider', () => {
    it('should use default provider when specified', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
        defaultProvider: 'OpenAI',
      }
      const testPrompt = 'Test prompt'
      const expectedResponse: AIResponse = { text: 'OpenAI response' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        AI_CONSTANTS.INFO.USING_DEFAULT_PROVIDER.replace('{provider}', 'OpenAI')
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        AI_CONSTANTS.INFO.PROVIDER_SUCCESS.replace('{provider}', 'OpenAI')
      )

      consoleSpy.mockRestore()
    })

    it('should fallback to other providers when default provider fails and fallback enabled', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
        defaultProvider: 'OpenAI',
      }
      const testPrompt = 'Test prompt'
      const expectedResponse: AIResponse = { text: 'Gemini response' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI failed')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider OpenAI failed: OpenAI failed')
      )

      consoleSpy.mockRestore()
    })

    it('should handle non-Error exceptions in default provider', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
        defaultProvider: 'OpenAI',
      }
      const testPrompt = 'Test prompt'
      const expectedResponse: AIResponse = { text: 'Gemini response' }

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        'String error'
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockResolvedValue(
        expectedResponse
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)
      const result = await manager.generateContent(testPrompt)

      expect(result).toEqual(expectedResponse)
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider OpenAI failed: String error')
      )

      consoleSpy.mockRestore()
    })

    it('should throw error when default provider fails and all fallback providers also fail', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
        defaultProvider: 'OpenAI',
      }
      const testPrompt = 'Test prompt'

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI failed')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('Gemini failed')
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)

      await expect(manager.generateContent(testPrompt)).rejects.toThrow(
        AI_CONSTANTS.ERRORS.ALL_PROVIDERS_FAILED
      )

      // Verify that both providers were called and failed
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )

      // Verify that error messages were logged (without checking exact format)
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider OpenAI failed: OpenAI failed')
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider Gemini failed: Gemini failed')
      )

      consoleSpy.mockRestore()
    })

    it('should throw error when default provider fails and fallback providers fail with non-Error exceptions', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
        defaultProvider: 'OpenAI',
      }
      const testPrompt = 'Test prompt'

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI failed')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockRejectedValue(
        'String error from Gemini'
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)

      await expect(manager.generateContent(testPrompt)).rejects.toThrow(
        AI_CONSTANTS.ERRORS.ALL_PROVIDERS_FAILED
      )

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          '❌ Provider Gemini failed: String error from Gemini'
        )
      )

      consoleSpy.mockRestore()
    })

    it('should throw error when no default provider and all providers fail', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Test prompt'

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('OpenAI failed')
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockRejectedValue(
        new Error('Gemini failed')
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)

      await expect(manager.generateContent(testPrompt)).rejects.toThrow(
        AI_CONSTANTS.ERRORS.ALL_PROVIDERS_FAILED
      )

      // Verify that both providers were called and failed
      expect(mockOpenAIProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )
      expect(mockGeminiProvider.generateContent).toHaveBeenCalledWith(
        testPrompt
      )

      // Verify that error messages were logged (without checking exact format)
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider OpenAI failed: OpenAI failed')
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('❌ Provider Gemini failed: Gemini failed')
      )

      consoleSpy.mockRestore()
    })

    it('should throw error when no default provider and all providers fail with non-Error exceptions', async () => {
      const config: AIConfig = {
        openaiApiKey: 'test-openai-key',
        geminiApiKey: 'test-gemini-key',
      }
      const testPrompt = 'Test prompt'

      ;(mockOpenAIProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockGeminiProvider.isAvailable as jest.Mock).mockReturnValue(true)
      ;(mockOpenAIProvider.generateContent as jest.Mock).mockRejectedValue(
        'String error from OpenAI'
      )
      ;(mockGeminiProvider.generateContent as jest.Mock).mockRejectedValue(
        'String error from Gemini'
      )

      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()

      const manager = createProviderManager(config)

      await expect(manager.generateContent(testPrompt)).rejects.toThrow(
        AI_CONSTANTS.ERRORS.ALL_PROVIDERS_FAILED
      )

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          '❌ Provider OpenAI failed: String error from OpenAI'
        )
      )
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          '❌ Provider Gemini failed: String error from Gemini'
        )
      )

      consoleSpy.mockRestore()
    })
  })
})
